import logging
import os
import shutil
import subprocess
from typing import Optional, Tuple

logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class CodeExecutor:
    """Handles writing, compiling (Verilog->C++->binary), and executing Verilog code using Verilator."""

    def write_code(self, file_path: str, code: str) -> None:
        """
        Writes the given code content to the specified file path.

        Args:
            file_path: The path where the code should be saved.
            code: The string content of the code.

        Raises:
            IOError: If writing to the file fails.
        """
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'w') as f:
                f.write(code)
            logger.info(f'Code successfully written to: {file_path}')
        except Exception as e:
            logger.error(f'Error writing file {file_path}: {e}')
            raise IOError(f'Could not write file: {file_path}') from e

    def _find_executable(self, name: str) -> Optional[str]:
        """Check if an executable exists in the system PATH."""
        if shutil.which(name):
            return name
        logger.error(f"'{name}' command not found. Please ensure it is installed and in your PATH.")
        return None

    def _get_top_module_name(self, verilog_file_path: str) -> Optional[str]:
        """Attempts to guess the top module name from the filename."""
        base = os.path.basename(verilog_file_path)
        name, ext = os.path.splitext(base)
        if ext.lower() == '.v':
            # Basic assumption: filename matches top module name
            # More robust parsing could be added here if needed
            return name
        logger.warning(f"Could not determine top module name from filename '{base}'. Assuming 'top'.")
        return 'top'  # Default fallback

    def compile_verilog(  # noqa: C901
        self,
        generated_v_path: str,
        target_v_path: str,
        sim_main_cpp_path: str,
    ) -> Tuple[bool, Optional[str], str, str]:
        """
        Compiles the generated Verilog testbench with the target module using Verilator.

        Args:
            generated_v_path: Path to the Verilog testbench file generated by the LLM.
            target_v_path: Path to the original target Verilog module file.
            sim_main_cpp_path: Path to the C++ simulation driver (e.g., sim_main.cpp).

        Returns:
            A tuple containing:
            - bool: True if Verilator compilation was successful, False otherwise.
            - Optional[str]: Path to the generated executable if successful, None otherwise.
            - str: stdout from Verilator compilation.
            - str: stderr from Verilator compilation.
        """
        output_dir = os.path.dirname(generated_v_path)
        obj_dir = os.path.join(output_dir, 'obj_dir')
        top_module = self._get_top_module_name(target_v_path)
        if not top_module:
            return False, None, '', 'Could not determine top module name.'
        executable_name = f'V{top_module}'
        executable_path = os.path.join(obj_dir, executable_name)

        verilator_exe = self._find_executable('verilator')
        if not verilator_exe:
            return False, None, '', 'Verilator executable not found.'

        # Ensure input files exist
        if not os.path.exists(target_v_path):
            error_msg = f'Target Verilog file not found: {target_v_path}'
            logger.error(error_msg)
            return False, None, '', error_msg
        if not os.path.exists(generated_v_path):
            error_msg = f'Generated Verilog file not found: {generated_v_path}'
            logger.error(error_msg)
            return False, None, '', error_msg
        if not os.path.exists(sim_main_cpp_path):
            error_msg = f'Simulation driver C++ file not found: {sim_main_cpp_path}'
            logger.error(error_msg)
            return False, None, '', error_msg

        # --- Verilator Compilation Step ---
        compile_command = [
            verilator_exe,
            '--cc',
            '--exe',
            '--binary',
            '-j',
            '0',
            '--top-module',
            top_module,
            '-o',
            executable_name,
            '--Mdir',
            obj_dir,
            sim_main_cpp_path,
            target_v_path,
            generated_v_path,
            '-Wall',
            '-Wno-fatal',
        ]

        logger.info(f"Verilator command: {' '.join(compile_command)}")
        compile_stdout = ''
        compile_stderr = ''

        try:
            compile_process = subprocess.run(  # noqa: S603
                compile_command,
                capture_output=True,
                text=True,
                check=False,
                timeout=300,
            )
            compile_stdout = compile_process.stdout
            compile_stderr = compile_process.stderr

            if compile_stdout:
                logger.debug('--- Verilator STDOUT ---')
                logger.debug(compile_stdout)
                logger.debug('------------------------')
            if compile_stderr:
                logger.warning('--- Verilator STDERR ---')
                logger.warning(compile_stderr)
                logger.warning('------------------------')

            if compile_process.returncode != 0:
                logger.error(f'Verilator compilation failed with return code {compile_process.returncode}.')
                return False, None, compile_stdout, compile_stderr

            # Check if executable exists after successful return code
            if not os.path.exists(executable_path):
                error_msg = f'Error: Verilator returned success but executable not found at {executable_path}.'
                logger.error(error_msg)
                return False, None, compile_stdout, compile_stderr + '\n' + error_msg

            logger.info(f'Verilator compilation successful. Executable created at: {executable_path}')
            return True, executable_path, compile_stdout, compile_stderr

        except subprocess.TimeoutExpired:
            error_msg = 'Error: Verilator compilation timed out.'
            logger.error(error_msg)
            return False, None, compile_stdout, compile_stderr + '\n' + error_msg
        except Exception as e:
            error_msg = f'An unexpected error occurred during Verilator compilation: {e}'
            logger.error(error_msg)
            return False, None, compile_stdout, compile_stderr + '\n' + error_msg

    def run_simulation(self, executable_path: str) -> Tuple[bool, str, str]:
        """
        Runs the compiled Verilator simulation executable.

        Args:
            executable_path: Path to the simulation executable.

        Returns:
            A tuple containing:
            - bool: True if simulation execution was successful (return code 0), False otherwise.
            - str: stdout from simulation execution.
            - str: stderr from simulation execution.
        """
        if not os.path.exists(executable_path):
            error_msg = f'Error: Simulation executable not found at {executable_path}. Cannot run simulation.'
            logger.error(error_msg)
            return False, '', error_msg

        logger.info(f'Executing simulation: {executable_path}')
        run_stdout = ''
        run_stderr = ''
        try:
            env = os.environ.copy()
            env['VERILATOR_SIM_TIME_LIMIT'] = '500'  # Make configurable later

            run_process = subprocess.run(  # noqa: S603
                [executable_path],
                capture_output=True,
                text=True,
                check=False,
                timeout=120,
                env=env,
            )
            run_stdout = run_process.stdout
            run_stderr = run_process.stderr

            logger.info(f'Simulation finished with return code: {run_process.returncode}')
            if run_stdout:
                logger.debug('--- Simulation STDOUT ---')
                logger.debug(run_stdout)
                logger.debug('-------------------------')
            if run_stderr:
                logger.warning('--- Simulation STDERR ---')
                logger.warning(run_stderr)
                logger.warning('-------------------------')

            success = run_process.returncode == 0
            if not success:
                logger.warning('Simulation execution failed or returned non-zero exit code.')

            return success, run_stdout, run_stderr

        except subprocess.TimeoutExpired:
            error_msg = 'Error: Simulation execution timed out.'
            logger.error(error_msg)
            return False, run_stdout, run_stderr + '\n' + error_msg
        except Exception as e:
            error_msg = f'An unexpected error occurred during simulation execution: {e}'
            logger.error(error_msg)
            return False, run_stdout, run_stderr + '\n' + error_msg
        finally:
            # Optional: Clean up obj_dir? Might be useful for debugging.
            # obj_dir = os.path.dirname(executable_path)
            # if os.path.exists(obj_dir):
            #     shutil.rmtree(obj_dir)
            pass
