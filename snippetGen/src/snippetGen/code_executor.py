import logging
import os
import re  # Import regex module
import shutil
import subprocess
from typing import Optional, Tuple

logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class CodeExecutor:
    """Handles writing, compiling (Verilog->C++->binary), and executing Verilog code using Verilator."""

    def write_code(self, file_path: str, code: str) -> None:
        """
        Writes the given code content to the specified file path, ensuring a trailing newline.

        Args:
            file_path: The path where the code should be saved.
            code: The string content of the code.

        Raises:
            IOError: If writing to the file fails.
        """
        try:
            if os.path.dirname(file_path) != '':
                os.makedirs(os.path.dirname(file_path), exist_ok=True)
            # Ensure the code ends with a newline
            if not code.endswith('\n'):
                code += '\n'
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            logger.info(f'Code successfully written to: {file_path}')
        except Exception as e:
            logger.error(f'Error writing file {file_path}: {e}')
            raise IOError(f'Could not write file: {file_path}') from e

    def _find_executable(self, name: str) -> Optional[str]:
        """Check if an executable exists in the system PATH."""
        if shutil.which(name):
            return name
        logger.error(f"'{name}' command not found. Please ensure it is installed and in your PATH.")
        return None

    def _guess_target_module_name_from_filename(self, verilog_file_path: str) -> Optional[str]:
        """Attempts to guess the target module name from the filename (for LLM prompts)."""
        base = os.path.basename(verilog_file_path)
        name, ext = os.path.splitext(base)
        # Allow .v and potentially other Verilog extensions like .sv
        if ext.lower() in ['.v', '.sv']:
            return name
        logger.warning(f"Could not determine target module name from filename '{base}'. Assuming 'top'.")
        return 'top'  # Default fallback

    def _extract_verilog_module_name(self, verilog_file_path: str) -> Optional[str]:
        """Extracts the first module name found in a Verilog file."""
        try:
            with open(verilog_file_path, 'r', encoding='utf-8') as f:
                # Read first few lines, should be enough for module declaration
                content = f.read(2048)  # Read up to 2KB
            # Regex to find 'module <name> ;' or 'module <name> (...);'
            # It captures the module name (alphanumeric + underscore)
            match = re.search(r'^\s*module\s+([a-zA-Z_]\w*)\s*(?:#\(.*?\))?\s*(?:\(.*\))?\s*;', content, re.MULTILINE)
            if match:
                module_name = match.group(1)
                logger.info(f"Extracted module name '{module_name}' from {verilog_file_path}")
                return module_name
            logger.error(f'Could not find module declaration in {verilog_file_path}')
            return None
        except FileNotFoundError:
            logger.error(f'File not found when trying to extract module name: {verilog_file_path}')
            return None
        except Exception as e:
            logger.error(f'Error reading file {verilog_file_path} to extract module name: {e}')
            return None

    def compile_verilog(  # noqa: C901
        self,
        generated_v_path: str,
        target_v_path: str,
        sim_main_cpp_path: str,
    ) -> Tuple[bool, Optional[str], str, str, Optional[str]]:
        """
        Compiles the generated Verilog testbench with the target module using Verilator.

        Args:
            generated_v_path: Path to the Verilog testbench file generated by the LLM.
            target_v_path: Path to the original target Verilog module file.
            sim_main_cpp_path: Path to the C++ simulation driver (e.g., sim_main.cpp).

        Returns:
            A tuple containing:
            - bool: True if Verilator compilation was successful, False otherwise.
            - Optional[str]: Path to the generated executable if successful, None otherwise.
            - str: stdout from Verilator compilation.
            - str: stderr from Verilator compilation.
            - Optional[str]: The determined top module name used for compilation.
        """
        output_dir = os.path.dirname(generated_v_path)
        obj_dir = os.path.join(output_dir or '.', 'obj_dir')  # Use '.' if output_dir is empty

        # Determine the top module name from the *generated* testbench file
        top_module = self._extract_verilog_module_name(generated_v_path)
        if not top_module:
            error_msg = f'Could not extract module name from generated Verilog file: {generated_v_path}'
            logger.error(error_msg)
            return False, None, '', error_msg, None

        # Executable name is based on the extracted top module (testbench)
        executable_name = f'V{top_module}'
        executable_path = os.path.join(obj_dir, executable_name)

        verilator_exe = self._find_executable('verilator')
        if not verilator_exe:
            return (
                False,
                None,
                '',
                'Verilator executable not found.',
                top_module,
            )  # Return determined top_module even on failure

        # Ensure input files exist
        if not os.path.exists(target_v_path):
            error_msg = f'Target Verilog file not found: {target_v_path}'
            logger.error(error_msg)
            return False, None, '', error_msg, top_module
        if not os.path.exists(generated_v_path):
            error_msg = f'Generated Verilog file not found: {generated_v_path}'
            logger.error(error_msg)
            # Cannot determine top_module if generated file doesn't exist
            return False, None, '', error_msg, None
        if not os.path.exists(sim_main_cpp_path):
            error_msg = f'Simulation driver C++ file not found: {sim_main_cpp_path}'
            logger.error(error_msg)
            return False, None, '', error_msg, top_module

        # --- Verilator Compilation Step ---
        # Use the extracted top_module name here
        compile_command = [
            verilator_exe,
            '--cc',
            '--exe',
            '--binary',
            '-j',
            '0',
            '--top-module',
            top_module,  # Use extracted name
            '-o',
            executable_name,  # Use name based on extracted top_module
            '--Mdir',
            obj_dir,
            sim_main_cpp_path,
            target_v_path,
            generated_v_path,
            '-Wall',
            '-Wno-fatal',
        ]

        logger.info(f"Verilator command: {' '.join(compile_command)}")
        compile_stdout = ''
        compile_stderr = ''

        try:
            compile_process = subprocess.run(  # noqa: S603
                compile_command,
                capture_output=True,
                text=True,
                check=False,
                timeout=300,
            )
            compile_stdout = compile_process.stdout
            compile_stderr = compile_process.stderr

            if compile_stdout:
                logger.debug('--- Verilator STDOUT ---')
                logger.debug(compile_stdout)
                logger.debug('------------------------')
            if compile_stderr:
                logger.warning('--- Verilator STDERR ---')
                logger.warning(compile_stderr)
                logger.warning('------------------------')

            if compile_process.returncode != 0:
                logger.error(f'Verilator compilation failed with return code {compile_process.returncode}.')
                # Return determined top_module even on failure
                return False, None, compile_stdout, compile_stderr, top_module

            # Check if executable exists after successful return code
            # executable_path is now correctly based on the extracted top_module
            if not os.path.exists(executable_path):
                error_msg = f'Error: Verilator returned success but executable not found at {executable_path}.'
                logger.error(error_msg)
                return False, None, compile_stdout, compile_stderr + '\n' + error_msg, top_module

            logger.info(f'Verilator compilation successful. Executable created at: {executable_path}')
            return True, executable_path, compile_stdout, compile_stderr, top_module

        except subprocess.TimeoutExpired:
            error_msg = 'Error: Verilator compilation timed out.'
            logger.error(error_msg)
            return False, None, compile_stdout, compile_stderr + '\n' + error_msg, top_module
        except Exception as e:
            error_msg = f'An unexpected error occurred during Verilator compilation: {e}'
            logger.error(error_msg)
            return False, None, compile_stdout, compile_stderr + '\n' + error_msg, top_module

    def run_simulation(self, executable_path: str) -> Tuple[bool, str, str]:
        """
        Runs the compiled Verilator simulation executable.

        Args:
            executable_path: Path to the simulation executable.

        Returns:
            A tuple containing:
            - bool: True if simulation execution was successful (return code 0), False otherwise.
            - str: stdout from simulation execution.
            - str: stderr from simulation execution.
        """
        if not os.path.exists(executable_path):
            error_msg = f'Error: Simulation executable not found at {executable_path}. Cannot run simulation.'
            logger.error(error_msg)
            return False, '', error_msg

        logger.info(f'Executing simulation: {executable_path}')
        run_stdout = ''
        run_stderr = ''
        try:
            env = os.environ.copy()
            env['VERILATOR_SIM_TIME_LIMIT'] = '500'  # Make configurable later

            run_process = subprocess.run(  # noqa: S603
                [executable_path],
                capture_output=True,
                text=True,
                check=False,
                timeout=120,
                env=env,
            )
            run_stdout = run_process.stdout
            run_stderr = run_process.stderr

            logger.info(f'Simulation finished with return code: {run_process.returncode}')
            if run_stdout:
                logger.debug('--- Simulation STDOUT ---')
                logger.debug(run_stdout)
                logger.debug('-------------------------')
            if run_stderr:
                logger.warning('--- Simulation STDERR ---')
                logger.warning(run_stderr)
                logger.warning('-------------------------')

            success = run_process.returncode == 0
            if not success:
                logger.warning('Simulation execution failed or returned non-zero exit code.')

            return success, run_stdout, run_stderr

        except subprocess.TimeoutExpired:
            error_msg = 'Error: Simulation execution timed out.'
            logger.error(error_msg)
            return False, run_stdout, run_stderr + '\n' + error_msg
        except Exception as e:
            error_msg = f'An unexpected error occurred during simulation execution: {e}'
            logger.error(error_msg)
            return False, run_stdout, run_stderr + '\n' + error_msg
        finally:
            # Optional: Clean up obj_dir? Might be useful for debugging.
            # obj_dir = os.path.dirname(executable_path)
            # if os.path.exists(obj_dir):
            #     shutil.rmtree(obj_dir)
            pass
