import logging
import os
import re
import shutil
import subprocess
from typing import Optional, Tuple

logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class CodeExecutor:
    """Handles writing and linting Verilog code using Verilator."""

    def write_code(self, file_path: str, code: str) -> None:
        """
        Writes the given code content to the specified file path, ensuring a trailing newline.

        Args:
            file_path: The path where the code should be saved.
            code: The string content of the code.

        Raises:
            IOError: If writing to the file fails.
        """
        try:
            # Ensure directory exists, handle case where file_path is just a filename
            dir_name = os.path.dirname(file_path)
            if dir_name and not os.path.exists(dir_name):
                os.makedirs(dir_name, exist_ok=True)

            # Ensure the code ends with a newline
            if not code.endswith('\n'):
                code += '\n'
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(code)
            logger.info(f'Code successfully written to: {file_path}')
        except Exception as e:
            logger.error(f'Error writing file {file_path}: {e}')
            raise IOError(f'Could not write file: {file_path}') from e

    def _find_executable(self, name: str) -> Optional[str]:
        """Check if an executable exists in the system PATH."""
        if shutil.which(name):
            return name
        logger.error(f"'{name}' command not found. Please ensure it is installed and in your PATH.")
        return None

    def _guess_target_module_name_from_filename(self, verilog_file_path: str) -> Optional[str]:
        """Attempts to guess the target module name from the filename (for LLM prompts)."""
        base = os.path.basename(verilog_file_path)
        name, ext = os.path.splitext(base)
        if ext.lower() in ['.v', '.sv']:
            return name
        logger.warning(f"Could not determine target module name from filename '{base}'. Assuming 'top'.")
        return 'top'

    def _extract_verilog_module_name(self, verilog_file_path: str) -> Optional[str]:
        """Extracts the first module name found in a Verilog file."""
        try:
            with open(verilog_file_path, 'r', encoding='utf-8') as f:
                content = f.read(2048)
            match = re.search(r'^\s*module\s+([a-zA-Z_]\w*)\s*(?:#\(.*?\))?\s*(?:\(.*\))?\s*;', content, re.MULTILINE)
            if match:
                module_name = match.group(1)
                logger.info(f"Extracted module name '{module_name}' from {verilog_file_path}")
                return module_name
            logger.warning(f'Could not find module declaration in {verilog_file_path}')  # Warning instead of error
            return None
        except FileNotFoundError:
            logger.error(f'File not found when trying to extract module name: {verilog_file_path}')
            return None
        except Exception as e:
            logger.error(f'Error reading file {verilog_file_path} to extract module name: {e}')
            return None

    def lint_verilog(self, generated_v_path: str) -> Tuple[bool, str, str]:
        """
        Lints the generated Verilog file using Verilator, assuming 'top' is the top module.

        Args:
            generated_v_path: Path to the Verilog file generated by the LLM.

        Returns:
            A tuple containing:
            - bool: True if Verilator linting passed (return code 0), False otherwise.
            - str: stdout from Verilator linting.
            - str: stderr from Verilator linting.
        """
        verilator_exe = self._find_executable('verilator')
        if not verilator_exe:
            return False, '', 'Verilator executable not found.'

        # Ensure generated file exists
        if not os.path.exists(generated_v_path):
            error_msg = f'Generated Verilog file not found for linting: {generated_v_path}'
            logger.error(error_msg)
            return False, '', error_msg

        lint_command = [
            verilator_exe,
            '--lint-only',
            '--no-timing',  # Keep this flag as prompts forbid #delays
            '-Wall',
            '-Wno-CMPCONST',
            '-Wno-DECLFILENAME',
            '-Wno-MULTIDRIVEN',
            '-Wno-NOLATCH',
            '-Wno-UNDRIVEN',
            '-Wno-UNOPTFLAT',
            '-Wno-UNUSED',
            '-Wno-UNSIGNED',
            '-Wno-WIDTHEXPAND',
            '-Wno-WIDTHTRUNC',
            '-Wno-MULTITOP',
            generated_v_path,  # Only lint the generated file
        ]

        logger.info(f"Verilator lint command: {' '.join(lint_command)}")
        lint_stdout = ''
        lint_stderr = ''

        try:
            lint_process = subprocess.run(  # noqa: S603
                lint_command,
                capture_output=True,
                text=True,
                check=False,
                timeout=120,
            )
            lint_stdout = lint_process.stdout
            lint_stderr = lint_process.stderr

            if lint_stdout:
                logger.debug('--- Verilator Lint STDOUT ---')
                logger.debug(lint_stdout)
                logger.debug('-----------------------------')
            if lint_stderr:
                logger.warning('--- Verilator Lint STDERR ---')
                logger.warning(lint_stderr)
                logger.warning('-----------------------------')

            if lint_process.returncode != 0:
                logger.error(f'Verilator linting failed with return code {lint_process.returncode}.')
                return False, lint_stdout, lint_stderr

            logger.info('Verilator linting successful.')
            return True, lint_stdout, lint_stderr

        except subprocess.TimeoutExpired:
            error_msg = 'Error: Verilator linting timed out.'
            logger.error(error_msg)
            return False, lint_stdout, lint_stderr + '\n' + error_msg
        except Exception as e:
            error_msg = f'An unexpected error occurred during Verilator linting: {e}'
            logger.error(error_msg)
            return False, lint_stdout, lint_stderr + '\n' + error_msg
